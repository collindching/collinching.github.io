<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-11-06T08:27:04-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Collin Ching</title><subtitle>Source code for my blog</subtitle><author><name>Collin Ching</name><email>collindching@gmail.com</email></author><entry><title type="html">My career priorities, dated October 2020</title><link href="http://localhost:4000/career-priorities/" rel="alternate" type="text/html" title="My career priorities, dated October 2020" /><published>2020-10-13T00:00:00-07:00</published><updated>2020-10-13T00:00:00-07:00</updated><id>http://localhost:4000/career-priorities</id><content type="html" xml:base="http://localhost:4000/career-priorities/">&lt;p&gt;I’ve been creeping on Blind lately, an app where software engineers and data scientists share their compensation packages from major tech companies. And while it is fun to see what my peers earn, scrolling through posts has also been stressful.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Am I paid enough? Can I get paid more? My life would be so much better if I had x more dollars. How do I raise my salary to y dollars? What company, which skills, what projects should I focus on to get more money?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I probably spent an entire week thinking solely about making more money, until it occurred to me that I hadn’t assessed how important salary was to me.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How important is money to me right now? What do I want out of my next job? What problems am I interested in solving? What do I want from life, in general?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I reflected on the questions above and realized that, while compensation was a top priority for people posting on Blind, skill development has been a higher short-term priority for me. Comparing myself to others on the basis on compensation reduced my worth to a single number that didn’t do my efforts jutstice.&lt;/p&gt;

&lt;p&gt;This brings me to the point of this post: it’s important to evaluate and record your career priorities and reasons for having them. Doing so forces you to consider what matters to you thoughtfully. And in times of doubt, having a record of your priorities can be helpful reminder to stick to your plan.&lt;/p&gt;

&lt;p&gt;With that in mind, here are my priorities as of October 2020.&lt;/p&gt;

&lt;h2 id=&quot;1-master-data-science-skills&quot;&gt;1. Master data science skills&lt;/h2&gt;

&lt;p&gt;My number 1 priority is to master technical skills and the business critical thinking necessary to do great data science.&lt;/p&gt;

&lt;p&gt;On the topic of technical skill development, I’m interested in learning statistical, ML, or programming concepts as they apply to driving high-impact business decisions or otherwise meaningful change. I have a lot on my learning wishlist, but topics that I want to tackle with greater depth are SQL, basics of data engineering, modeling techniques and ML algorithms, methods of model deployment, experimentation methods, and causal inference.&lt;/p&gt;

&lt;p&gt;On the softer side, I’m interested in honing the critical thinking that is required to identify a meaningful and important business problem, explore that problem’s business and data context rigorously, and build an actionable solution. Mastering this skill is more important to me than mastering any one technical skill. I believe the challenge may be navigating many constraints and coming up with creative solutions in the absence of perfect data.&lt;/p&gt;

&lt;p&gt;To note, I am prioritizing skill mastery of career advancements. Given the option to either advance my skills or receive a promotion, I’m willing to forego a short-term salary bump if it means faster growth as a data scientist. In the mid-term and long-term, I believe good career advancement opportunities will follow as a lagging measure of skill mastery.&lt;/p&gt;

&lt;p&gt;As a rule, as I pursue this goal I will focus on active learning and deliberate practice, with building, drilling, and writing as my main processes for learning. Anything I learn passively through reading or coursework I intend to reinforce through an active learning process. While this may lead to slower progress and greater effort on my end, I believe this will be most effective for my growth.&lt;/p&gt;

&lt;h2 id=&quot;2-build-great-learning-and-working-habits&quot;&gt;2. Build great learning and working habits&lt;/h2&gt;

&lt;p&gt;Since learning will be crucial for my personal and career development, I am convinced that optimizing my learning habits would pay huge dividends. In studying the art of learning, my goal is to collect strategies that can lead to a lifetime of more efficient and effective learning.&lt;/p&gt;

&lt;p&gt;Primarily, I’ll be studying recurring behaviors that top performers use to achieve their goals, writing down their principles and habits, and applying and refining a strategy that works best for myself.&lt;/p&gt;

&lt;p&gt;My process for accomplishing this goal will be reading and summarizing books about learning, capturing the key strategies on my personal blog, and then keeping myself accountable to the habits that are most important.&lt;/p&gt;

&lt;p&gt;I am very excited about this priority and how it will affect my life outside of just work.&lt;/p&gt;

&lt;h2 id=&quot;3-learn-how-the-world-operates&quot;&gt;3. Learn how the world operates&lt;/h2&gt;

&lt;p&gt;Abstractly, I’d like to learn how the world works and how people operate both as individuals and as members of systems. Reading and reflecting on these questions will hopefully help me discover questions that matter to me.&lt;/p&gt;

&lt;p&gt;As a more concrete goal, I’d like to accumulate a collection of mental models that I can refer to about how and why things happen, and tie these back into my life in some way. Maybe some of these can be a basis for a future project or career move in data science, and help me improve either my life or someone else’s life.&lt;/p&gt;

&lt;p&gt;As a habit, I’ll aim to read a diverse range of non-fiction subjects – economics, psychology, biographies, history, science – and amass a centralized collection of written notes. This will be the foundation for connecting ideas between disciplines and brainstorming new ideas.&lt;/p&gt;</content><author><name>Collin Ching</name><email>collindching@gmail.com</email></author><summary type="html">Why scrolling Blind is dangerous, and why setting personal goals is important</summary></entry><entry><title type="html">How to program and debug more effectively as a data scientist</title><link href="http://localhost:4000/programming-lessons/" rel="alternate" type="text/html" title="How to program and debug more effectively as a data scientist" /><published>2020-08-23T00:00:00-07:00</published><updated>2020-08-23T00:00:00-07:00</updated><id>http://localhost:4000/programming-lessons</id><content type="html" xml:base="http://localhost:4000/programming-lessons/">&lt;p&gt;Recently, I delivered my first software package, designed to automate some time-intensive calculations that are critical to my team’s data workflow. The process included more debug cycles than I care to admit, partly because of growing code complexity and evolving requirements, and partly because I could have planned and executed more effectively.&lt;/p&gt;

&lt;p&gt;After some reflection, here are some key lessons from that experience, which can help you write software more effectively as a data scientist.&lt;/p&gt;

&lt;h3 id=&quot;1-map-out-your-software-design&quot;&gt;1. Map out your software design&lt;/h3&gt;

&lt;p&gt;When I started my project, I dove into coding with limited upfront planning, thinking that the exact details of my software design would become clearer as I coded.&lt;/p&gt;

&lt;p&gt;As my code became more complex, I started losing track of how all my functions fit together. When requirements changed, I had to reinvest time into understanding my code to make desired modifications.&lt;/p&gt;

&lt;p&gt;Avoiding this pitfall takes relatively little effort. Have a simple, but clear picture of what your software does at a high-level, whether you draw out a diagram or take notes on your software’s design and functions. Keeping a sketch with pen-and-paper and boxes and arrows would suffice. I personally wrote bullets on a working document that I could constantly modify.&lt;/p&gt;

&lt;p&gt;There are several advantages of keeping a design map. For one, documenting your software design will give you a clearer idea of how all your code pieces fit together. Verbalizing the logic of your data manipulations can help you sense check that your logic will give you your intended result. And of course, having a clear reference becomes extremely handy when you need to make bigger changes to the design of your code.&lt;/p&gt;

&lt;h3 id=&quot;2-invest-in-file-organization&quot;&gt;2. Invest in file organization&lt;/h3&gt;

&lt;p&gt;Between multiple scripts and Excel files, I grossly underestimated the number of files that I would be navigating throughout my project. When my ad-hoc file naming system eventually failed, I found myself re-writing several functions because I couldn’t find the original files in which I’d written them.&lt;/p&gt;

&lt;p&gt;Investing in your organization will inevitably reduce stress down the line, and improve long-term efficiency. Before starting a project, it’s helpful to invest some upfront effort to define a clear, maintainable file organization and naming system.&lt;/p&gt;

&lt;p&gt;Some basics guidelines would be to have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A separate folder for each project you’re working on&lt;/li&gt;
  &lt;li&gt;A folder for each of your respective file categories (i.e. scripts, data, outputs, QA, etc.)&lt;/li&gt;
  &lt;li&gt;A consistent naming convention for code&lt;/li&gt;
  &lt;li&gt;A consistent naming convention for your data files&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Beyond that, I found it helpful to use version tags and date tags on code and data files (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;v2-file-2020-08-03&lt;/code&gt;), to make it easier to navigate by chronology.&lt;/p&gt;

&lt;h3 id=&quot;3-validate-each-code-unit&quot;&gt;3. Validate each code unit&lt;/h3&gt;

&lt;p&gt;Debugging was the most painful part of my programming project by far. This pain often stemmed narrowing down the location of bugs. One lesson I learned was to validate regularly at each transformation step, to ensure that any data processing result had values and dimensions I expected.&lt;/p&gt;

&lt;p&gt;This allowed me to catch unexpected behavior early on, and allowed me to be confident about data at each step.&lt;/p&gt;

&lt;p&gt;A couple basic checks that I regularly used:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Checking number of rows before and after joining two data frames&lt;/li&gt;
  &lt;li&gt;Checking that sums of variables match up before and after processing&lt;/li&gt;
  &lt;li&gt;Checking for missing values&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To increase efficiency and repeat keystrokes, I would think about ways to automate validation, either through by creating simple validation functions or Excel templates. For me, time invested in automating validation easily paid itself off tenfold.&lt;/p&gt;

&lt;h3 id=&quot;4-debug-methodically&quot;&gt;4. Debug methodically&lt;/h3&gt;

&lt;p&gt;When errors arise, debugging by following your instincts can sometimes pay off. But without a plan, this approach can be arbitrary and frustrating. In the long-term, following a methodical debugging procedure is a more effective strategy.&lt;/p&gt;

&lt;p&gt;Building a system in which you narrow down sources of error and document attempted solutions can help you more effectively circle in on a solution. Moreover, this keeps stress at bay, allowing you to focus on debugging with an organized and calm mind.&lt;/p&gt;

&lt;p&gt;At a high-level, I think a system should involve understanding the error message, developing context around the bug, and testing and documenting solutions in an organized fashion. In this system, you get more control over your debugging process, a reference document for future debugging cycles, and significant reduction in stress in exchange for a small additional investment in time and effort. The procedure that I’ve been using is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If there is an error message, read it carefully and look it up; if not, describe the unexpected behavior in writing&lt;/li&gt;
  &lt;li&gt;Narrow down the location of the offending code by inserting manual tests&lt;/li&gt;
  &lt;li&gt;Once you’ve identified where the error occurs, check the structure, format, and values of the data entering your offending code – usually this will lead to a solution&lt;/li&gt;
  &lt;li&gt;Fix, re-run, evaluate, document&lt;/li&gt;
  &lt;li&gt;If the error persists, research the error further and test again&lt;/li&gt;
  &lt;li&gt;If the error persists, ask for debugging help&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While your system might be different, I think the core principles will be the same: understand your error, locate the bug, investigate obvious sources of error, and test and document.&lt;/p&gt;

&lt;h3 id=&quot;5-document-bugs-and-solutions&quot;&gt;5. Document bugs and solutions&lt;/h3&gt;

&lt;p&gt;In the course of my project, I caught myself debugging the same problem several times, which was an inefficient use of time.&lt;/p&gt;

&lt;p&gt;To avoid solving the same problem twice, I started maintaining a document of bugs that I ran into, along with their solutions. This reference also has a preventative benefit, allowing me to keep track of common bugs and avoid making those mistakes in the first place.&lt;/p&gt;

&lt;p&gt;I suggest keeping your solution document simple; you can keep track of each error you face in a spreadsheet – mine only has four columns: error, context, solution, and notes for next time.&lt;/p&gt;</content><author><name>Collin Ching</name><email>collindching@gmail.com</email></author><summary type="html">Lessons from my first data science software project</summary></entry></feed>